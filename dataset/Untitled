<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="dialog">
<config key="internal_node_subsettings">
<entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
</config>
<config key="model">
<entry key="sourceCode" type="xstring" value="import numpy as np%%00010import scipy.spatial.distance as dist%%00010%%00010#temos 15 utilizadores aqui, não sei porque%%00010#vou separar cada utilizador com os seus ratings%%00010def ratings_of_users(ratings,user_max):%%00010%%00010%%00009ratings_users = {}%%00010%%00010%%00009for i in range(1,user_max):%%00010%%00009%%00009tmp = []%%00010%%00009%%00009ratings_users[&quot;user_&quot;+str(i)] = []%%00010%%00010%%00009for row in ratings:%%00010%%00009%%00009id = np.int(row[0])%%00010%%00009%%00009ratings_users[&quot;user_&quot;+str(id)].append((row[3],row[1]));%%00010%%00009%%00009%%00010%%00009return ratings_users;%%00010%%00010def best_matches(ratings,user):%%00010%%00009%%00010%%00009specific_ratings_user = ratings[user]%%00010%%00009ratings.__delitem__(user)%%00010%%00010%%00009#todos os filmes referentes ao user a prever%%00010%%00009x = len(specific_ratings_user)%%00010%%00009movies_user = np.empty((1,x),np.int)%%00010%%00009i=0;%%00010%%00009for tuplo in specific_ratings_user:%%00010%%00009%%00009movies_user[0][i] = tuplo[1]%%00010%%00009%%00009i = i+1;%%00010%%00010%%00009#agora preciso de todos os movies e ratings dos outros utilizadores%%00010%%00009#que avaliaram os mesmos movies que o user especifico%%00010%%00009ratings_users = {}%%00010%%00010%%00009for i in ratings:%%00010%%00009%%00009tmp = []%%00010%%00009%%00009ratings_users[i] = []%%00010%%00009%%00009%%00010%%00009for row in ratings:%%00010%%00009%%00009%%00010%%00009%%00009for tuplo in ratings[row]:%%00010%%00009%%00009%%00009movie = tuplo[1]%%00009%%00010%%00009%%00009%%00009%%00010%%00009%%00009%%00009if (movie in movies_user[0]):%%00010%%00009%%00009%%00009%%00009ratings_users[row].append((tuplo[0],tuplo[1]))%%00010%%00010%%00009return specific_ratings_user,ratings_users%%00010%%00010#dá uma lista com as similaridades entre utilizadores%%00010#vou ao utilizador que quero prever e para cada outro utilizador%%00010#encontro filmes que ambos avaliaram e calculo a similaridade%%00010def similaridade(user, group_of_users):%%00010%%00010%%00009#users%%00010%%00009ratings_similar = {}%%00010%%00009similarity_between_users = {}%%00010%%00009%%00010%%00009#specific user%%00010%%00009ratings_similar[&quot;user&quot;] = [];%%00010%%00009movies_user = []%%00010%%00009%%00010%%00009#para cada utilizador%%00010%%00009for x in group_of_users:%%00010%%00010%%00009%%00009#percorremos os filmes%%00010%%00009%%00009for tuplo in group_of_users[x]:%%00010%%00009%%00009%%00009#só quero os filmes que o user1 avaliou%%00009semelhantes ao user2%%00009%%00010%%00009%%00009%%00009for movie in user:%%00010%%00009%%00009%%00009%%00009if(movie[1]==tuplo[1]):%%00010%%00009%%00009%%00009%%00009%%00009ratings_similar[&quot;user&quot;].append(movie[0])%%00010%%00009%%00009%%00010%%00009%%00009#print(&quot;user to predict = &quot; + str(ratings_similar[&quot;user&quot;]))%%00010%%00009%%00009#print(&quot;user to compare = &quot; + str(group_of_users[x]));%%00010%%00010%%00009%%00009tmp = []%%00010%%00009%%00009for i in group_of_users[x]:%%00010%%00009%%00009%%00009tmp.append(i[0])%%00010%%00010%%00009%%00009group_of_users[x] = tmp%%00010%%00010%%00009%%00009#print(&quot;user to predict = &quot; + str(ratings_similar[&quot;user&quot;]))%%00010%%00009%%00009#print(&quot;user to compare = &quot; + str(group_of_users[x]));%%00010%%00009%%00009%%00010%%00009%%00009#calcular a similaridade com a euclidian distance%%00010%%00009%%00009if( ratings_similar[&quot;user&quot;] != [] and  group_of_users[x] != []):%%00010%%00009%%00009%%00009similarity_between_users[x] = dist.euclidean(ratings_similar[&quot;user&quot;], group_of_users[x])%%00010%%00009%%00009%%00009%%00010%%00009%%00009ratings_similar[&quot;user&quot;] = [];%%00010%%00009%%00010%%00009return similarity_between_users;%%00010%%00009%%00009%%00010%%00009%%00010%%00010ratings = input_table.copy().to_numpy()%%00010ratings_users = ratings_of_users(ratings,16)%%00010ratings_specifi_user,ratings_users = best_matches(ratings_users,&quot;user_1&quot;)%%00010similarity_between_users = similaridade(ratings_specifi_user,ratings_users);%%00010%%00010#print(ratings_specifi_user)%%00010#print(ratings_users)"/>
<entry key="rowLimit" type="xint" value="1000"/>
<entry key="pythonVersionOption" type="xstring" value="python3"/>
<entry key="python2Command" type="xstring" value=""/>
<entry key="python3Command" type="xstring" value=""/>
<entry key="chunkSize" type="xint" value="500000"/>
<entry key="convertMissingToPython" type="xboolean" value="false"/>
<entry key="convertMissingFromPython" type="xboolean" value="false"/>
<entry key="sentinelOption" type="xstring" value="MIN_VAL"/>
<entry key="sentinelValue" type="xint" value="0"/>
</config>
</config>
